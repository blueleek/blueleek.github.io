I"L<h2 id="模块查找的流程">模块查找的流程</h2>
<p>在开发过程中我们会经常使用require方法，但是可能会忽略它内部的细节，require的时候是怎样查到到对应的模块？其实Node在面对不同的路径标识符有不同的处理：</p>

<h2 id="内置模块">内置模块</h2>
<p>像 http, net, stream 这样的模块, Node 早已经将这样的模块编译为二进制模块, 在 Node 启动的时候就已经加入到内存中了，所以省略了查找定位文件与编译文件的步骤。这样的模块加载是最快的。</p>

<h2 id="绝对路径相对路径模块">绝对路径/相对路径模块</h2>
<p>在识别路径标识符的时候，如果标识符前面有 ./ 或 .. 或者 / 这样的字符，那么就会被当作相对路径或者是绝对路径，然后解析得到一个真实的路径之后开始查找文件。
Node 的模块机制会先把标识符当作是一个文件名来处理，来查找文件，并且如果省缺了后缀名会按照 .js, .json, .node 的顺序来尝试加载，如果没有找到对应的文件的话， 那么就会将这个标识符当作是一个目录来查找，node 会查找该目录下的 package.json, 解析出 json 中的 main 字段，根据 main 字段中指定的文件路径查找指定文件:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="dl">"</span><span class="s2">main</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">start.js</span><span class="dl">"</span> <span class="c1">// 当 require 的时候，会优先查看此字段，若无则查找 index.js/index.json/index.node</span>
<span class="p">}</span>
</code></pre></div></div>
<p>如果没有指定文件或者找不到指定的文件的话，然后就会在该目录下按照 index.js, index.json, index.node 的顺序来加载，如果还是没有找到的话，那么就会抛出一个无法找到文件的错误。</p>

<h1 id="npm-模块包">NPM 模块包</h1>
<p>如果路径标识符既不是内置模块路径，又不是相对路径或绝对路径的话， 就会被当作是 NPM 模块包来加载， 而它的加载顺序是可以使用 module.paths 来查看。
module.paths 返回是一个数组，第一个元素是文件当前目录下的 node_modules 文件夹，越往后就是上一级目录的 node_modules 文件夹，直到查找到 home 目录下的 node_modules 文件夹。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">/</span> <span class="nx">module</span><span class="p">.</span><span class="nx">js</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">module</span><span class="p">.</span><span class="nx">paths</span><span class="p">);</span>

<span class="c1">// 打印结果</span>
<span class="p">[</span> <span class="dl">'</span><span class="s1">D:</span><span class="se">\\</span><span class="s1">side project</span><span class="se">\\</span><span class="s1">test</span><span class="se">\\</span><span class="s1">node_modules</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">D:</span><span class="se">\\</span><span class="s1">side project</span><span class="se">\\</span><span class="s1">node_modules</span><span class="dl">'</span><span class="p">,</span>
  <span class="dl">'</span><span class="s1">D:</span><span class="se">\\</span><span class="s1">node_modules</span><span class="dl">'</span> <span class="p">]</span>
</code></pre></div></div>

<p>由此可以知道，如果文件的层级越深，那么查找逻辑也会越复杂，加载也会越慢。
在每一个查找文件路径的节点也就是各文件层级的 node_modules 文件夹下，类似于相对路径或绝对路径模块的加载逻辑，node 会在各个 node_modules 下先查找以标识符为主的分别是 .js, .json, .node 后缀的文件，如果没有找到，那么就当作是一个目录来进行来查找目录下的 package.json, 并解析出其中的 main 字段指定的文件路径，如果没有文件路径或者文件路径错误，目录下的 index.js, index.json, index.node, 如果没有查找到上述的文件，那么就会抛出一个错误。
可以看到其实相对/绝对路径的加载逻辑与 NPM 模块的加载逻辑是类似的，下面提供一个流程图来帮助理解：
<img src="https://img-blog.csdnimg.cn/20191112160605733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hodGh3eA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>

<h2 id="requireresolve">require.resolve</h2>
<p>知晓了上面的查找逻辑，Node 模块本身提供了一个查找路径的方法：require.resolve. 这个方法可以帮助你检查这个模块是否存在。</p>

<h1 id="模块是什么">模块是什么</h1>
<p>在 Node 里面，每个模块其实是一个对象：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">Module</span> <span class="p">{</span>
  <span class="nl">id</span><span class="p">:</span> <span class="dl">'</span><span class="s1">.</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">exports</span><span class="p">:</span> <span class="p">{},</span>
  <span class="nx">parent</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">filename</span><span class="p">:</span> <span class="dl">'</span><span class="s1">D:</span><span class="se">\\</span><span class="s1">side project</span><span class="se">\\</span><span class="s1">test</span><span class="se">\\</span><span class="s1">test.js</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">loaded</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="nx">children</span><span class="p">:</span> <span class="p">[],</span>
  <span class="nx">paths</span><span class="p">:</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">D:</span><span class="se">\\</span><span class="s1">side project</span><span class="se">\\</span><span class="s1">test</span><span class="se">\\</span><span class="s1">node_modules</span><span class="dl">'</span><span class="p">,</span>
    <span class="dl">'</span><span class="s1">D:</span><span class="se">\\</span><span class="s1">side project</span><span class="se">\\</span><span class="s1">node_modules</span><span class="dl">'</span><span class="p">,</span>
    <span class="dl">'</span><span class="s1">D:</span><span class="se">\\</span><span class="s1">node_modules</span><span class="dl">'</span><span class="p">]</span> 
<span class="p">}</span>
</code></pre></div></div>
<p>可以看到， Module 对象里面存储了很多关于模块的信息，而理解这些信息对于理解模块机制是重要的。
我们来实际看一下一个简单的模块引用的例子：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// lib.js</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">in lib</span><span class="dl">'</span><span class="p">,</span> <span class="nx">module</span><span class="p">);</span>

<span class="c1">// index.js</span>
<span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">./lib.js</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">in index</span><span class="dl">'</span><span class="p">,</span> <span class="nx">module</span><span class="p">);</span>
</code></pre></div></div>
<p>打印出来的结果是：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">in</span> <span class="nx">lib</span> <span class="nx">Module</span> <span class="p">{</span>
  <span class="nl">id</span><span class="p">:</span> <span class="dl">'</span><span class="s1">D:</span><span class="se">\\</span><span class="s1">side project</span><span class="se">\\</span><span class="s1">test</span><span class="se">\\</span><span class="s1">lib.js</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">exports</span><span class="p">:</span> <span class="p">{},</span>
  <span class="nx">parent</span><span class="p">:</span>
   <span class="nx">Module</span> <span class="p">{</span>
     <span class="nl">id</span><span class="p">:</span> <span class="dl">'</span><span class="s1">.</span><span class="dl">'</span><span class="p">,</span>
     <span class="nx">exports</span><span class="p">:</span> <span class="p">{},</span>
     <span class="nx">parent</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
     <span class="nx">filename</span><span class="p">:</span> <span class="dl">'</span><span class="s1">D:</span><span class="se">\\</span><span class="s1">side project</span><span class="se">\\</span><span class="s1">test</span><span class="se">\\</span><span class="s1">index.js</span><span class="dl">'</span><span class="p">,</span>
     <span class="nx">loaded</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
     <span class="nx">children</span><span class="p">:</span> <span class="p">[</span> <span class="p">[</span><span class="nx">Circular</span><span class="p">]</span> <span class="p">],</span>
     <span class="nx">paths</span><span class="p">:</span>
      <span class="p">[</span> <span class="p">[</span><span class="nb">Array</span><span class="p">]</span> <span class="p">]</span> <span class="p">},</span>
  <span class="nx">filename</span><span class="p">:</span> <span class="dl">'</span><span class="s1">D:</span><span class="se">\\</span><span class="s1">side project</span><span class="se">\\</span><span class="s1">test</span><span class="se">\\</span><span class="s1">lib.js</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">loaded</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="nx">children</span><span class="p">:</span> <span class="p">[],</span>
  <span class="nx">paths</span><span class="p">:</span>
   <span class="p">[</span> <span class="p">[</span><span class="nb">Array</span><span class="p">]</span> <span class="p">]</span> <span class="p">}</span>
<span class="k">in</span> <span class="nx">index</span> <span class="nx">Module</span> <span class="p">{</span>
  <span class="nl">id</span><span class="p">:</span> <span class="dl">'</span><span class="s1">.</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">exports</span><span class="p">:</span> <span class="p">{},</span>
  <span class="nx">parent</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">filename</span><span class="p">:</span> <span class="dl">'</span><span class="s1">D:</span><span class="se">\\</span><span class="s1">side project</span><span class="se">\\</span><span class="s1">test</span><span class="se">\\</span><span class="s1">index.js</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">loaded</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
  <span class="nx">children</span><span class="p">:</span>
   <span class="p">[</span> <span class="nx">Module</span> <span class="p">{</span>
       <span class="nl">id</span><span class="p">:</span> <span class="dl">'</span><span class="s1">D:</span><span class="se">\\</span><span class="s1">side project</span><span class="se">\\</span><span class="s1">test</span><span class="se">\\</span><span class="s1">lib.js</span><span class="dl">'</span><span class="p">,</span>
       <span class="nx">exports</span><span class="p">:</span> <span class="p">{},</span>
       <span class="nx">parent</span><span class="p">:</span> <span class="p">[</span><span class="nx">Circular</span><span class="p">],</span>
       <span class="nx">filename</span><span class="p">:</span> <span class="dl">'</span><span class="s1">D:</span><span class="se">\\</span><span class="s1">side project</span><span class="se">\\</span><span class="s1">test</span><span class="se">\\</span><span class="s1">lib.js</span><span class="dl">'</span><span class="p">,</span>
       <span class="nx">loaded</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
       <span class="nx">children</span><span class="p">:</span> <span class="p">[],</span>
       <span class="nx">paths</span><span class="p">:</span> <span class="p">[</span><span class="nb">Array</span><span class="p">]</span> <span class="p">}</span> <span class="p">],</span>
  <span class="nx">paths</span><span class="p">:</span>
   <span class="p">[</span> <span class="p">[</span><span class="nb">Array</span><span class="p">]</span> <span class="p">]</span> <span class="p">}</span>
</code></pre></div></div>
<p>我们可以看到在模块中，模块 Module 对象会使用 parent 与 child 这一对键值对来保存父子引用关系并保存对应的模块信息对象。注意一下这里父子对象表示信息，我们看到，lib 的模块对象中的 parent 属性存储着父模块对象 index 的模块信息，而指向的父模块信息中会使用 child 属性来存储 lib 模块的模块信息，为了避免出现无限循环显示模块信息的问题，这里会使用一个 [Circular] 来代替原有的指向。
注意这里为了简洁，将模块中的 path 数组信息省略为 [Array].</p>

<h2 id="exports-与-moduleexports">exports 与 module.exports</h2>
<p>我们在模块中会使用 exports 与 module.exports 这两个变量来暴露出模块的一些属性或者方法，但是我们会发现在使用的时候，如果不小心会导致模块无法被正确暴露出需要的信息：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 正确</span>
<span class="nx">exports</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">shawncheung</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">exports</span><span class="p">.</span><span class="nx">sex</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">man</span><span class="dl">'</span><span class="p">;</span>

<span class="c1">// 错误</span>
<span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">shawncheung</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">sex</span><span class="p">:</span> <span class="dl">'</span><span class="s1">man</span><span class="dl">'</span>
<span class="p">};</span>
</code></pre></div></div>
<p>出现上面的情况是因为没有理解 exports 与 module.exports 的关系，他们之间的关系其实是：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">exports</span> <span class="o">=</span> <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{};</span>
</code></pre></div></div>
<p>可见，exports 只是一个 module.exports 的引用而已，如果我们对 exports 重新赋值，那么 exports 的引用指向就会改变了，就像错误示例一样，对于 exports 的修改是没有办法反应到 module.exports 上面的。可以理解为 exports 是 module.exports 的一个快捷方式。而最终模块的导出对象是以 module.exports 这个值为准的。如果像错误示例那样，最终模块暴露出去的仅仅是一个空对象而已。</p>

<h2 id="loaded">loaded</h2>
<p>很明显, 这个属性是用于说明这个模块是否已经加载完成的. 但是疑问就在于上面的模块信息打印出来 loaded 都是 flase, 这是为什么? 这个是因为 loaded 这个值的改变是会在下一个事件循环中修改, 如果这个模块加载完成的话, 那么就会修改该值为 ture.</p>

<h1 id="模块的缓存">模块的缓存</h1>

<p>不管什么样的模块, 所有的模块都是有缓存的：来看下面的 demo</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// test.js</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">test</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{};</span>

<span class="c1">//index.js</span>
<span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">test</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">test</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">test</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>
<p>上面的例子我们直接使用 Node index.js 来执行就会发现 test 字符串只打印了一次，也就是说查找执行模块只执行了一次，后面的 require 的时候，Node 会直接使用模块暴露出来的 module.exports 结果进行使用。在二次加载的时候, 会去直接读取模块缓存中加载模块暴露出来的 exports 对象, 而不是重新执行上面那样复杂的加载流程, 极大地优化了性能. 而所有缓存的模块的信息都可以在 require.cache 上面找到.</p>

<h1 id="模块的编写">模块的编写</h1>
<p>如果你的模块是一个函数, 而且你想让这个模块在 require 的时候和直接在命令行的时候都可以被执行传参的话, 那么可以借用 require.main 来判断当前文件是否被直接执行:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">require</span><span class="p">.</span><span class="nx">main</span> <span class="o">===</span> <span class="nx">module</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">func</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">argv</span><span class="p">.</span><span class="nx">slice</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">func</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

:ET