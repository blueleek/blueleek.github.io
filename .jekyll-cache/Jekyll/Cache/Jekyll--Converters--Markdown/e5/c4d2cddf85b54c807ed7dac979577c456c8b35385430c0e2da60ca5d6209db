I":<p>早起一道算法题，清神洗脑。<br />
寻找两链表的交叉点，最初的实现思路是计算出两链表的长度，利用链表长度的差值，将两链表的头节点移动到相同距离的起点位置进行移动，直到节点相遇。<br />
按照这样思路确实可以实现，只是代码写起来很不优雅，在 Discuss 中看到 most votes 解决方案，使用了一种很 tricky 的解决方法，对两个长度不同的链表进行遍历，至尾节点时将头节点指向对方头部节点，最终指针遍历路程相同时，二者即在交叉点相遇.</p>

<h3 id="problem-description">Problem Description</h3>

<blockquote>
  <p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>

  <p>For example, the following two linked lists: <br />
<img src="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png" alt="" />
To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.
begin to intersect at node c1.<br />
Example 1:
<img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" alt="" /></p>

  <p>Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3<br /></p>

  <p>Output: Reference of the node with value = 8<br /></p>

  <p>Input Explanation: The intersected node’s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</p>

  <p>Example 2: <br />
<img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" alt="" /></p>

  <p>Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 <br /></p>

  <p>Output: Reference of the node with value = 2 <br /></p>

  <p>Input Explanation: The intersected node’s value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.<br /></p>

  <p>Example 3:<br />
<img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" alt="" /></p>

  <p>Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 <br /></p>

  <p>Output: null <br /></p>

  <p>Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.
Explanation: The two lists do not intersect, so return null.</p>

  <p>Note:</p>
  <ul>
    <li>If the two linked lists have no intersection at all, return null.</li>
    <li>The linked lists must retain their original structure after the function returns.</li>
    <li>You may assume there are no cycles anywhere in the entire linked structure.</li>
    <li>Your code should preferably run in O(n) time and use only O(1) memory.</li>
  </ul>
</blockquote>

<h3 id="方法一">方法一：</h3>
<p>思路：求出两链表的长度，利用长度差值，将遍历的起始点移动到相等距离位置<br />
代码示例：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function getLen (head) {
    var len = 0;
    while (head !== null) {
        len += 1;
        head = head.next
  }
    return len;
}

var getIntersectionNode = function(headA, headB) {
    if (headA === null || headB === null) {
        return null;
    }
    
    var lenA = getLen(headA);
    var lenB = getLen(headB);
    if (lenA &gt; lenB) {
        while (lenA !== lenB) {
            headA = headA.next;
            lenA = lenA - 1;
        }
    }
   if (lenA &lt; lenB) {
        while (lenA !== lenB) {
            headB = headB.next;
            lenB = lenB - 1;
        }
   }
    
    
   while (true) {
       if (headA === headB) {
           return headA;
       }
       headA = headA.next;
       headB = headB.next;
   }
   return null;  
};

</code></pre></div></div>

<h3 id="方法二">方法二：</h3>
<p>思路：对两链表进行遍历，至尾节点时将指针移至对方头节点，最终指针遍历路程相等时，二者相遇，即为交叉点或者无交叉点<br />
代码示例：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const getIntersectionNode = (headA, headB) =&gt; {
    if (!headA || !headB) {
        return null
    }
    
    let p1 = headA
    let p2 = headB
    
    while (p1 !== p2) {
        p1 = p1 ? p1.next : headB
        p2 = p2 ? p2.next : headA
    }
    
    return p1
}
</code></pre></div></div>

:ET