I")<h2 id="什么是闭包">什么是闭包？</h2>

<blockquote>
  <p>红宝书定义： 闭包是指有权访问另外一个函数作用域中变量的函数</p>

  <p>MDN 闭包定义： 闭包是指那些能够访问自由变量的函数。</p>
</blockquote>

<h3 id="闭包产生的原因">闭包产生的原因？</h3>
<p>理解闭包，首先要明白作用域的概念，在 ES5 中只存在两种作用域-全局作用域和函数作用域，当访问一个变量时，解释器会首先在当前作用查找标识符，如果没有找到，就去父作用域找，直到找到该变量的标示符不在父作用域中，这就是作用域链，每个子函数会拷贝上级的作用域，形成一个作用域链条。
如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var a = 1;
function f1() {
  var a = 2;
  function f2() {
    var a = 3;
    console.log(a); //3
  }
}
</code></pre></div></div>
<p>这段代码中，<code class="highlighter-rouge">f1</code> 的作用域指向有全局作用域和它本身，而 <code class="highlighter-rouge">f2</code> 的作用域指向全局作用域，<code class="highlighter-rouge">f1</code> 和它本身。作用域是从最底层向上找，直到找到全局作用域为止，如果全局还没有的话就报错。</p>

<p>闭包产生的本质就是当前环境中存在指向父级作用域的引用。如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function f1(){
  var a = 2;
  function f2() {
    console.log(a); // 2   
 }
 return f2;
}
var x = f1();
x(); // 2
</code></pre></div></div>

<p>这里 <code class="highlighter-rouge">x</code> 会拿到父级作用域中的变量，输出 2，因为在当前环境中，含有对 <code class="highlighter-rouge">f2</code> 的引用，<code class="highlighter-rouge">f2</code> 恰恰引用了 <code class="highlighter-rouge">window</code>，<code class="highlighter-rouge">f1</code>，和 <code class="highlighter-rouge">f2</code> 的作用域。因此 <code class="highlighter-rouge">f2</code> 可以访问到 <code class="highlighter-rouge">f1</code> 的作用域的变量。</p>

<h2 id="白话解读闭包">白话解读闭包</h2>
<p>很多书籍上闭包的概念很抽象，很难理解，简单说闭包就是可以读取其他函数内部变量的函数。由于JS 语言中，只有函数内部的子函数才可以读取外部的局部变量，因此可以把闭包简单理解为“定义在一个函数内部的函数”</p>

<h2 id="闭包的用途">闭包的用途</h2>

<ul>
  <li>读取函数内部的变量</li>
  <li>保存变量的引用，让这些变量的值始终保持在内存中</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function f1(){

　　　　var n=999;

　　　　nAdd=function(){n+=1}

　　　　function f2(){
　　　　　　alert(n);
　　　　}

　　　　return f2;

　　}

　　var result=f1();

　　result(); // 999

　　nAdd();

　　result(); // 1000
</code></pre></div></div>
<p>这段代码中，<code class="highlighter-rouge">result</code> 实际上是一个闭包函数，一共运行了两次，第一次的值是 999，第二次是 1000，说明函数 <code class="highlighter-rouge">f1</code> 中的局部变量一直保存在内存中，并没有在 <code class="highlighter-rouge">f1</code> 调用后被自动清除。</p>

<p>为什么会这样呢？原因就在于 <code class="highlighter-rouge">f1</code> 是 <code class="highlighter-rouge">f2</code> 的父函数，而 <code class="highlighter-rouge">f2</code> 被赋给了一个全局变量，这导致 <code class="highlighter-rouge">f2</code> 始终在内存中，而 <code class="highlighter-rouge">f2</code> 的存在依赖于 <code class="highlighter-rouge">f1</code>，因此 <code class="highlighter-rouge">f1</code> 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p>

<p>这段代码中，<code class="highlighter-rouge">nAdd=function(){n+=1}</code> 这一行，<code class="highlighter-rouge">nAdd</code> 前面没有使用 <code class="highlighter-rouge">var</code> 关键字，因此 <code class="highlighter-rouge">nAdd</code> 是一个全局变量，而不是局部变量。其次 <code class="highlighter-rouge">nAdd</code> 的值是一个匿名函数，而这个匿名函数本身也是一个闭包，所以 <code class="highlighter-rouge">nAdd</code> 相当于一个 <code class="highlighter-rouge">setter</code>，可以在函数外部对函数内部的局部变量进行操作。</p>

<h2 id="如何解决下面的循环输出问题">如何解决下面的循环输出问题？</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for(var i = 1; i &lt;= 5; i ++){
  setTimeout(function timer(){
    console.log(i)
  }, 0)
}
</code></pre></div></div>
<p>为什么会全部输出6？
<code class="highlighter-rouge">setTimeout</code> 为宏任务，由于 JS 中单线程 <code class="highlighter-rouge">eventLoop</code> 机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后 <code class="highlighter-rouge">setTimeout</code> 中的回调才依次执行，但输出 <code class="highlighter-rouge">i</code> 的时候当前作用域没有，往上一级再找，发现了 <code class="highlighter-rouge">i</code>,此时循环已经结束，<code class="highlighter-rouge">i</code> 变成了 6。因此会全部输出 6。</p>

<ul>
  <li>解法1：利用 IIFE (立即执行函数表达式)当每次 <code class="highlighter-rouge">for</code> 循环时，把此时的 <code class="highlighter-rouge">i</code> 变量传递到定时器中</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> for(var i = 1;i &lt;= 5;i++){
  (function(j){
    setTimeout(function timer(){
      console.log(j)
    }, 0)
  })(i)
}
</code></pre></div></div>

<ul>
  <li>解法2：给定时器传入第三个参数, 作为 <code class="highlighter-rouge">timer</code> 函数的第一个函数参数</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for(var i=1;i&lt;=5;i++){
  setTimeout(function timer(j){
    console.log(j)
  }, 0, i)
}
</code></pre></div></div>

<ul>
  <li>解法3</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="kd">function</span> <span class="nx">timer</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
  <span class="p">},</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="使用闭包的注意点">使用闭包的注意点</h2>

<ol>
  <li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li>
  <li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>
</ol>
:ET