I"|
<p>二叉树是一种非常重要的数据结构，很多数据结构都是基于二叉树演变而来。对于二叉树，一般有前序、中序、后序和层序遍历这几种方法。<br />
今天借助 LeetCode 这道题复习一下二叉树前序遍历的实现。</p>

<h2 id="问题描述">问题描述</h2>
<blockquote>
  <p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>

  <p>Example:
Input: [1,null,2,3]</p>

  <p><img src="https://img-blog.csdnimg.cn/20200107231133530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hodGh3eA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
</blockquote>

<h2 id="题解">题解</h2>

<h3 id="方法一递归遍历">方法一：递归遍历</h3>
<p>类似于在二叉树中查找一个键的递归算法：</p>
<blockquote>
  <p>如果树是空的，则查找未命中，如果查找的键和 root 节点的键值相等，查找命中，否则我们就（递归）在适当的子树木中继续查找。</p>
</blockquote>

<p>停止递归调用的条件是节点为 null<br />
代码实现：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function recursive(root, arr) {
    if (root === null) return;

    arr.push(root.val);
    recursive(root.left, arr)
    recursive(root.right, arr)
}
var preorderTraversal = function(root) {
    var arr = [];
    recursive(root, arr)
    return arr; 
};

</code></pre></div></div>
<p>时间复杂度： O(n)<br />
空间复杂度： O(lg(n)) ~ O(n)</p>

<h3 id="方法二-模拟栈调用操作">方法二： 模拟栈调用操作</h3>
<p>也可以不采用递归的方法进行遍历，模拟栈调用实现遍历
代码实现：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var preorderTraversal = function(root) {
  if (!root) return [];
  var result = [];
  var stack = [root];
  
  while(stack.length) {
    var node = stack.pop();
    result.push(node.val);
    if (node.right) stack.push(node.right);
    if (node.left) stack.push(node.left);
  }
  return result;
};
</code></pre></div></div>
<p>时间复杂度： O(n)<br />
空间复杂度： O(lg(n)) ~ O(n)</p>

<p>其实和二叉树有关的算法基本都可以用递归实现，可以先用简单的树形结构帮助确定循环条件。<br /></p>

<p>欲遍历整棵树，可以先递归遍历其子树，因为每个节点都可以视为父节点。子树达到目标，整棵树自然达到目的。使用递归调用方式代码简洁，模拟调用栈操作的方式复杂些，但可以帮助更好的理解栈调用的过程。</p>
:ET